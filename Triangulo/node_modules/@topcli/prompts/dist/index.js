// src/prompts/question.ts
import { EOL as EOL2 } from "os";
import kleur2 from "kleur";
import wcwidth from "@topcli/wcwidth";

// src/prompts/abstract.ts
import { EOL } from "os";
import { createInterface } from "readline";
import { Writable } from "stream";
import EventEmitter from "events";

// src/utils.ts
import process2 from "process";
var kAnsiRegex = ansiRegex();
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    // eslint-disable-next-line max-len
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
function stripAnsi(string) {
  return string.replace(kAnsiRegex, "");
}
function isUnicodeSupported() {
  if (process2.platform !== "win32") {
    return process2.env.TERM !== "linux";
  }
  return Boolean(process2.env.WT_SESSION) || Boolean(process2.env.TERMINUS_SUBLIME) || process2.env.ConEmuTask === "{cmd::Cmder}" || process2.env.TERM_PROGRAM === "Terminus-Sublime" || process2.env.TERM_PROGRAM === "vscode" || process2.env.TERM === "xterm-256color" || process2.env.TERM === "alacritty" || process2.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// src/prompt-agent.ts
var kPrivateInstancier = Symbol("instancier");
var PromptAgent = class _PromptAgent {
  /**
   * The prompts answers queue.
   * When not empty, any prompt will be answered by the first answer in this list.
   */
  nextAnswers = [];
  /**
   * The shared PromptAgent.
   */
  static #this;
  static agent() {
    return this.#this ??= new _PromptAgent(kPrivateInstancier);
  }
  constructor(instancier) {
    if (instancier !== kPrivateInstancier) {
      throw new Error("Cannot instanciate PromptAgent, use PromptAgent.agent() instead");
    }
  }
  /**
   * Programmatically set the next answer for any prompt (`question()`, `confirm()`, `select()`)
   *
   * This is useful for testing.
   *
   * @example
   * ```js
   * const promptAgent = PromptAgent.agent();
   * promptAgent.nextAnswer("toto");
   *
   * const input = await question("what is your name?");
   * assert.equal(input, "toto");
   * ```
   */
  nextAnswer(value) {
    if (Array.isArray(value)) {
      this.nextAnswers.push(...value);
      return;
    }
    this.nextAnswers.push(value);
  }
};

// src/errors/abort.ts
var AbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
};

// src/prompts/abstract.ts
var AbstractPrompt = class _AbstractPrompt extends EventEmitter {
  stdin;
  stdout;
  message;
  signal;
  history;
  agent;
  mute;
  rl;
  #signalHandler;
  constructor(options) {
    super();
    if (this.constructor === _AbstractPrompt) {
      throw new Error("AbstractPrompt can't be instantiated.");
    }
    const {
      stdin: input = process.stdin,
      stdout: output = process.stdout,
      message,
      signal
    } = options;
    if (typeof message !== "string") {
      throw new TypeError(`message must be string, ${typeof message} given.`);
    }
    if (!output.isTTY) {
      Object.assign(output, {
        moveCursor: () => void 0,
        clearScreenDown: () => void 0
      });
    }
    this.stdin = input;
    this.stdout = output;
    this.message = message;
    this.signal = signal;
    this.history = [];
    this.agent = PromptAgent.agent();
    this.mute = false;
    if (this.stdout.isTTY) {
      this.stdin.setRawMode(true);
    }
    this.rl = createInterface({
      input,
      output: new Writable({
        write: (chunk, encoding, callback) => {
          if (!this.mute && chunk) {
            this.stdout.write(chunk, encoding);
          }
          callback();
        }
      }),
      terminal: true
    });
    if (this.signal) {
      this.#signalHandler = () => {
        this.rl.close();
        for (let i = 0; i < this.history.length; i++) {
          this.clearLastLine();
        }
        this.emit("error", new AbortError("Prompt aborted"));
      };
      this.signal.addEventListener("abort", this.#signalHandler, { once: true });
    }
  }
  write(data) {
    const formattedData = stripAnsi(data).replace(EOL, "");
    if (formattedData) {
      this.history.push(formattedData);
    }
    return this.stdout.write(data);
  }
  clearLastLine() {
    const lastLine = this.history.pop();
    if (!lastLine) {
      return;
    }
    const lastLineRows = Math.ceil(stripAnsi(lastLine).length / this.stdout.columns);
    this.stdout.moveCursor(-this.stdout.columns, -lastLineRows);
    this.stdout.clearScreenDown();
  }
  destroy() {
    this.rl.close();
    if (this.signal) {
      this.signal.removeEventListener("abort", this.#signalHandler);
    }
  }
};

// src/constants.ts
import kleur from "kleur";
var kMainSymbols = {
  tick: "\u2714",
  cross: "\u2716",
  pointer: "\u203A",
  previous: "\u2B61",
  next: "\u2B63",
  active: "\u25CF",
  inactive: "\u25CB"
};
var kFallbackSymbols = {
  tick: "\u221A",
  cross: "\xD7",
  pointer: ">",
  previous: "\u2191",
  next: "\u2193",
  active: "(+)",
  inactive: "(-)"
};
var kSymbols = isUnicodeSupported() || process.env.CI ? kMainSymbols : kFallbackSymbols;
var kPointer = kleur.gray(kSymbols.pointer);
var SYMBOLS = {
  QuestionMark: kleur.blue().bold("?"),
  Tick: kleur.green().bold(kSymbols.tick),
  Cross: kleur.red().bold(kSymbols.cross),
  Pointer: kPointer,
  Previous: kSymbols.previous,
  Next: kSymbols.next,
  ShowCursor: "\x1B[?25h",
  HideCursor: "\x1B[?25l",
  Active: kleur.cyan(kSymbols.active),
  Inactive: kleur.gray(kSymbols.inactive)
};

// src/prompts/question.ts
var QuestionPrompt = class extends AbstractPrompt {
  defaultValue;
  tip;
  questionSuffixError;
  answer;
  answerBuffer;
  #validators;
  #secure;
  constructor(options) {
    const {
      defaultValue,
      validators = [],
      secure = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    if (defaultValue && typeof defaultValue !== "string") {
      throw new TypeError("defaultValue must be a string");
    }
    this.defaultValue = defaultValue;
    this.tip = this.defaultValue ? ` (${this.defaultValue})` : "";
    this.#validators = validators;
    this.#secure = Boolean(secure);
    this.questionSuffixError = "";
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.history.push(questionQuery);
      this.rl.question(questionQuery, (answer) => {
        this.history.push(questionQuery + answer);
        this.mute = false;
        resolve(answer);
      });
      this.mute = this.#secure;
    });
  }
  #getQuestionQuery() {
    return `${kleur2.bold(`${SYMBOLS.QuestionMark} ${this.message}${this.tip}`)} ${this.questionSuffixError}`;
  }
  #setQuestionSuffixError(error) {
    const suffix = kleur2.red(`[${error}] `);
    this.questionSuffixError = suffix;
  }
  #writeAnswer() {
    const prefix = this.answer ? SYMBOLS.Tick : SYMBOLS.Cross;
    const answer = kleur2.yellow(this.#secure ? "CONFIDENTIAL" : this.answer ?? "");
    this.write(`${prefix} ${kleur2.bold(this.message)} ${SYMBOLS.Pointer} ${answer}${EOL2}`);
  }
  #onQuestionAnswer() {
    const questionLineCount = Math.ceil(
      wcwidth(stripAnsi(this.#getQuestionQuery() + this.answer)) / this.stdout.columns
    );
    this.stdout.moveCursor(-this.stdout.columns, -questionLineCount);
    this.stdout.clearScreenDown();
    for (const validator of this.#validators) {
      if (!validator.validate(this.answer)) {
        const error = validator.error(this.answer);
        this.#setQuestionSuffixError(error);
        this.answerBuffer = this.#question();
        return;
      }
    }
    this.answerBuffer = void 0;
    this.#writeAnswer();
  }
  question() {
    return new Promise(async (resolve, reject) => {
      this.answer = this.agent.nextAnswers.shift();
      if (this.answer !== void 0) {
        this.#writeAnswer();
        this.destroy();
        resolve(this.answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.answer = await this.#question();
      if (this.answer === "" && this.defaultValue) {
        this.answer = this.defaultValue;
      }
      this.#onQuestionAnswer();
      while (this.answerBuffer !== void 0) {
        this.answer = await this.answerBuffer;
        this.#onQuestionAnswer();
      }
      this.destroy();
      resolve(this.answer);
    });
  }
};

// src/prompts/confirm.ts
import { EOL as EOL3 } from "os";
import kleur3 from "kleur";
import wcwidth2 from "@topcli/wcwidth";
var kToggleKeys = /* @__PURE__ */ new Set([
  "left",
  "right",
  "tab",
  "q",
  "a",
  "d",
  "h",
  "j",
  "k",
  "l",
  "space"
]);
var ConfirmPrompt = class extends AbstractPrompt {
  initial;
  selectedValue;
  fastAnswer;
  #boundKeyPressEvent;
  #boundExitEvent;
  constructor(options) {
    const {
      initial = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.initial = initial;
    this.selectedValue = initial;
  }
  #getHint() {
    const Yes = kleur3.bold().underline().cyan("Yes");
    const No = kleur3.bold().underline().cyan("No");
    return this.selectedValue ? `${Yes}/No` : `Yes/${No}`;
  }
  #render() {
    this.write(this.#getQuestionQuery());
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.write(questionQuery);
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #onKeypress(resolve, value, key) {
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor(wcwidth2(stripAnsi(this.#getQuestionQuery())) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    if (key.name === "return") {
      resolve(this.selectedValue);
      return;
    }
    if (kToggleKeys.has(key.name ?? "")) {
      this.selectedValue = !this.selectedValue;
    }
    if (key.name === "y") {
      this.selectedValue = true;
      resolve(true);
      this.fastAnswer = true;
    } else if (key.name === "n") {
      this.selectedValue = false;
      resolve(false);
      this.fastAnswer = true;
    }
    if (!this.fastAnswer) {
      this.#render();
    }
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
  }
  #getQuestionQuery() {
    const query = kleur3.bold(`${SYMBOLS.QuestionMark} ${this.message}`);
    return `${query} ${this.#getHint()}`;
  }
  #onQuestionAnswer() {
    this.clearLastLine();
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor(wcwidth2(stripAnsi(this.#getQuestionQuery())) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    this.write(`${this.selectedValue ? SYMBOLS.Tick : SYMBOLS.Cross} ${kleur3.bold(this.message)}${EOL3}`);
  }
  confirm() {
    return new Promise(async (resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.selectedValue = answer;
        this.#onQuestionAnswer();
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      try {
        await this.#question();
        this.#onQuestionAnswer();
        resolve(this.selectedValue);
      } finally {
        this.write(SYMBOLS.ShowCursor);
        this.#onProcessExit();
        process.off("exit", this.#boundExitEvent);
        this.destroy();
      }
    });
  }
};

// src/prompts/select.ts
import { EOL as EOL4 } from "os";
import kleur4 from "kleur";
import wcwidth3 from "@topcli/wcwidth";
var kRequiredChoiceProperties = ["label", "value"];
var SelectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  activeIndex = 0;
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      validators = [],
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${EOL4}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceSelected = choiceIndex === this.activeIndex;
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = " ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous;
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next;
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? `${SYMBOLS.Pointer} ` : "  "}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const color = isChoiceSelected ? kleur4.white().bold : kleur4.gray;
      const str = `${prefix}${color(`${formattedLabel}${formattedDescription}`)}${EOL4}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(choice) {
    const symbolPrefix = choice === "" ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${symbolPrefix} ${kleur4.bold(this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = kleur4.yellow(typeof choice === "string" ? choice : choice.label);
    this.write(`${prefix} ${formattedChoice}${EOL4}`);
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.name === "return") {
      const choice = this.filteredChoices[this.activeIndex] || "";
      const label = typeof choice === "string" ? choice : choice.label;
      const value = typeof choice === "string" ? choice : choice.value;
      for (const validator of this.#validators) {
        if (!validator.validate(value)) {
          const error = validator.error(value);
          render({ error });
          return;
        }
      }
      render({ clearRender: true });
      if (!this.options.ignoreValues?.includes(value)) {
        this.#showAnsweredQuestion(label);
      }
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(value);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  select() {
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.#showAnsweredQuestion(answer);
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              wcwidth3(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            wcwidth3(stripAnsi(this.questionMessage)) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil(wcwidth3(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = "";
    if (error) {
      hint = ` ${hint.length > 0 ? " " : ""}${kleur4.red().bold(`[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${kleur4.bold(this.message)}${hint}`;
    this.write(`${this.questionMessage}${EOL4}`);
  }
};

// src/prompts/multiselect.ts
import { EOL as EOL5 } from "os";
import kleur5 from "kleur";
import wcwidth4 from "@topcli/wcwidth";
var kRequiredChoiceProperties2 = ["label", "value"];
var MultiselectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  #showHint;
  activeIndex = 0;
  selectedIndexes = /* @__PURE__ */ new Set();
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      preSelectedChoices,
      validators = [],
      showHint = true,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    this.#showHint = showHint;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties2) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
    if (!preSelectedChoices) {
      return;
    }
    for (const choice of preSelectedChoices) {
      const choiceIndex = this.filteredChoices.findIndex((item) => {
        if (typeof item === "string") {
          return item === choice;
        }
        return item.value === choice;
      });
      if (choiceIndex === -1) {
        this.destroy();
        throw new Error(`Invalid pre-selected choice: ${typeof choice === "string" ? choice : choice.value}`);
      }
      this.selectedIndexes.add(choiceIndex);
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${EOL5}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceActive = choiceIndex === this.activeIndex;
      const isChoiceSelected = this.selectedIndexes.has(choiceIndex);
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = "  ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous + " ";
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next + " ";
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? SYMBOLS.Active : SYMBOLS.Inactive}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const color = isChoiceActive ? kleur5.white().bold : kleur5.gray;
      const str = `${prefix} ${color(`${formattedLabel}${formattedDescription}`)}${EOL5}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(choices, isAgentAnswer = false) {
    const prefixSymbol = this.selectedIndexes.size === 0 && !isAgentAnswer ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${prefixSymbol} ${kleur5.bold(this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = kleur5.yellow(choices);
    this.write(`${prefix}${choices ? ` ${formattedChoice}` : ""}${EOL5}`);
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.ctrl && key.name === "a") {
      this.selectedIndexes = this.selectedIndexes.size === this.filteredChoices.length ? /* @__PURE__ */ new Set() : new Set(this.filteredChoices.map((_, index) => index));
      render();
    } else if (key.name === "right") {
      this.selectedIndexes.add(this.activeIndex);
      render();
    } else if (key.name === "left") {
      this.selectedIndexes = new Set([...this.selectedIndexes].filter((index) => index !== this.activeIndex));
      render();
    } else if (key.name === "return") {
      const labels = [...this.selectedIndexes].map((index) => {
        const choice = this.filteredChoices[index];
        return typeof choice === "string" ? choice : choice.label;
      });
      const values = [...this.selectedIndexes].map((index) => {
        const choice = this.filteredChoices[index];
        return typeof choice === "string" ? choice : choice.value;
      });
      for (const validator of this.#validators) {
        if (!validator.validate(values)) {
          const error = validator.error(values);
          render({ error });
          return;
        }
      }
      render({ clearRender: true });
      this.#showAnsweredQuestion(labels.join(", "));
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(values);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.selectedIndexes.clear();
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  multiselect() {
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        const formatedAnser = Array.isArray(answer) ? answer.join(", ") : answer;
        this.#showAnsweredQuestion(formatedAnser, true);
        this.destroy();
        resolve(Array.isArray(answer) ? answer : [answer]);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              wcwidth4(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            wcwidth4(stripAnsi(this.questionMessage)) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil(wcwidth4(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = this.#showHint ? kleur5.gray(
      // eslint-disable-next-line max-len
      `(Press ${kleur5.bold("<Ctrl+A>")} to toggle all, ${kleur5.bold("<Left/Right>")} to toggle, ${kleur5.bold("<Return>")} to submit)`
    ) : "";
    if (error) {
      hint += `${hint.length > 0 ? " " : ""}${kleur5.red().bold(`[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${kleur5.bold(this.message)}${hint.length > 0 ? ` ${hint}` : ""}`;
    this.write(`${this.questionMessage}${EOL5}`);
  }
};

// src/validators.ts
function required() {
  return {
    validate: (input) => Array.isArray(input) ? input.length > 0 : Boolean(input),
    error: () => "required"
  };
}

// index.ts
async function question(message, options = {}) {
  return new QuestionPrompt({ ...options, message }).question();
}
async function select(message, options) {
  const selectPrompt = new SelectPrompt({ ...options, message });
  return selectPrompt.select();
}
async function confirm(message, options) {
  const confirmPrompt = new ConfirmPrompt({ ...options, message });
  return confirmPrompt.confirm();
}
async function multiselect(message, options) {
  const multiselectPrompt = new MultiselectPrompt({ ...options, message });
  return multiselectPrompt.multiselect();
}
export {
  PromptAgent,
  confirm,
  multiselect,
  question,
  required,
  select
};
