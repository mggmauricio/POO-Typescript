var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var prompts_exports = {};
__export(prompts_exports, {
  PromptAgent: () => PromptAgent,
  confirm: () => confirm,
  multiselect: () => multiselect,
  question: () => question,
  required: () => required,
  select: () => select
});
module.exports = __toCommonJS(prompts_exports);

// src/prompts/question.ts
var import_node_os2 = require("os");
var import_kleur2 = __toESM(require("kleur"), 1);
var import_wcwidth = __toESM(require("@topcli/wcwidth"), 1);

// src/prompts/abstract.ts
var import_node_os = require("os");
var import_node_readline = require("readline");
var import_node_stream = require("stream");
var import_node_events = __toESM(require("events"), 1);

// src/utils.ts
var import_node_process = __toESM(require("process"), 1);
var kAnsiRegex = ansiRegex();
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    // eslint-disable-next-line max-len
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
function stripAnsi(string) {
  return string.replace(kAnsiRegex, "");
}
function isUnicodeSupported() {
  if (import_node_process.default.platform !== "win32") {
    return import_node_process.default.env.TERM !== "linux";
  }
  return Boolean(import_node_process.default.env.WT_SESSION) || Boolean(import_node_process.default.env.TERMINUS_SUBLIME) || import_node_process.default.env.ConEmuTask === "{cmd::Cmder}" || import_node_process.default.env.TERM_PROGRAM === "Terminus-Sublime" || import_node_process.default.env.TERM_PROGRAM === "vscode" || import_node_process.default.env.TERM === "xterm-256color" || import_node_process.default.env.TERM === "alacritty" || import_node_process.default.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// src/prompt-agent.ts
var kPrivateInstancier = Symbol("instancier");
var PromptAgent = class _PromptAgent {
  /**
   * The prompts answers queue.
   * When not empty, any prompt will be answered by the first answer in this list.
   */
  nextAnswers = [];
  /**
   * The shared PromptAgent.
   */
  static #this;
  static agent() {
    return this.#this ??= new _PromptAgent(kPrivateInstancier);
  }
  constructor(instancier) {
    if (instancier !== kPrivateInstancier) {
      throw new Error("Cannot instanciate PromptAgent, use PromptAgent.agent() instead");
    }
  }
  /**
   * Programmatically set the next answer for any prompt (`question()`, `confirm()`, `select()`)
   *
   * This is useful for testing.
   *
   * @example
   * ```js
   * const promptAgent = PromptAgent.agent();
   * promptAgent.nextAnswer("toto");
   *
   * const input = await question("what is your name?");
   * assert.equal(input, "toto");
   * ```
   */
  nextAnswer(value) {
    if (Array.isArray(value)) {
      this.nextAnswers.push(...value);
      return;
    }
    this.nextAnswers.push(value);
  }
};

// src/errors/abort.ts
var AbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
};

// src/prompts/abstract.ts
var AbstractPrompt = class _AbstractPrompt extends import_node_events.default {
  stdin;
  stdout;
  message;
  signal;
  history;
  agent;
  mute;
  rl;
  #signalHandler;
  constructor(options) {
    super();
    if (this.constructor === _AbstractPrompt) {
      throw new Error("AbstractPrompt can't be instantiated.");
    }
    const {
      stdin: input = process.stdin,
      stdout: output = process.stdout,
      message,
      signal
    } = options;
    if (typeof message !== "string") {
      throw new TypeError(`message must be string, ${typeof message} given.`);
    }
    if (!output.isTTY) {
      Object.assign(output, {
        moveCursor: () => void 0,
        clearScreenDown: () => void 0
      });
    }
    this.stdin = input;
    this.stdout = output;
    this.message = message;
    this.signal = signal;
    this.history = [];
    this.agent = PromptAgent.agent();
    this.mute = false;
    if (this.stdout.isTTY) {
      this.stdin.setRawMode(true);
    }
    this.rl = (0, import_node_readline.createInterface)({
      input,
      output: new import_node_stream.Writable({
        write: (chunk, encoding, callback) => {
          if (!this.mute && chunk) {
            this.stdout.write(chunk, encoding);
          }
          callback();
        }
      }),
      terminal: true
    });
    if (this.signal) {
      this.#signalHandler = () => {
        this.rl.close();
        for (let i = 0; i < this.history.length; i++) {
          this.clearLastLine();
        }
        this.emit("error", new AbortError("Prompt aborted"));
      };
      this.signal.addEventListener("abort", this.#signalHandler, { once: true });
    }
  }
  write(data) {
    const formattedData = stripAnsi(data).replace(import_node_os.EOL, "");
    if (formattedData) {
      this.history.push(formattedData);
    }
    return this.stdout.write(data);
  }
  clearLastLine() {
    const lastLine = this.history.pop();
    if (!lastLine) {
      return;
    }
    const lastLineRows = Math.ceil(stripAnsi(lastLine).length / this.stdout.columns);
    this.stdout.moveCursor(-this.stdout.columns, -lastLineRows);
    this.stdout.clearScreenDown();
  }
  destroy() {
    this.rl.close();
    if (this.signal) {
      this.signal.removeEventListener("abort", this.#signalHandler);
    }
  }
};

// src/constants.ts
var import_kleur = __toESM(require("kleur"), 1);
var kMainSymbols = {
  tick: "\u2714",
  cross: "\u2716",
  pointer: "\u203A",
  previous: "\u2B61",
  next: "\u2B63",
  active: "\u25CF",
  inactive: "\u25CB"
};
var kFallbackSymbols = {
  tick: "\u221A",
  cross: "\xD7",
  pointer: ">",
  previous: "\u2191",
  next: "\u2193",
  active: "(+)",
  inactive: "(-)"
};
var kSymbols = isUnicodeSupported() || process.env.CI ? kMainSymbols : kFallbackSymbols;
var kPointer = import_kleur.default.gray(kSymbols.pointer);
var SYMBOLS = {
  QuestionMark: import_kleur.default.blue().bold("?"),
  Tick: import_kleur.default.green().bold(kSymbols.tick),
  Cross: import_kleur.default.red().bold(kSymbols.cross),
  Pointer: kPointer,
  Previous: kSymbols.previous,
  Next: kSymbols.next,
  ShowCursor: "\x1B[?25h",
  HideCursor: "\x1B[?25l",
  Active: import_kleur.default.cyan(kSymbols.active),
  Inactive: import_kleur.default.gray(kSymbols.inactive)
};

// src/prompts/question.ts
var QuestionPrompt = class extends AbstractPrompt {
  defaultValue;
  tip;
  questionSuffixError;
  answer;
  answerBuffer;
  #validators;
  #secure;
  constructor(options) {
    const {
      defaultValue,
      validators = [],
      secure = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    if (defaultValue && typeof defaultValue !== "string") {
      throw new TypeError("defaultValue must be a string");
    }
    this.defaultValue = defaultValue;
    this.tip = this.defaultValue ? ` (${this.defaultValue})` : "";
    this.#validators = validators;
    this.#secure = Boolean(secure);
    this.questionSuffixError = "";
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.history.push(questionQuery);
      this.rl.question(questionQuery, (answer) => {
        this.history.push(questionQuery + answer);
        this.mute = false;
        resolve(answer);
      });
      this.mute = this.#secure;
    });
  }
  #getQuestionQuery() {
    return `${import_kleur2.default.bold(`${SYMBOLS.QuestionMark} ${this.message}${this.tip}`)} ${this.questionSuffixError}`;
  }
  #setQuestionSuffixError(error) {
    const suffix = import_kleur2.default.red(`[${error}] `);
    this.questionSuffixError = suffix;
  }
  #writeAnswer() {
    const prefix = this.answer ? SYMBOLS.Tick : SYMBOLS.Cross;
    const answer = import_kleur2.default.yellow(this.#secure ? "CONFIDENTIAL" : this.answer ?? "");
    this.write(`${prefix} ${import_kleur2.default.bold(this.message)} ${SYMBOLS.Pointer} ${answer}${import_node_os2.EOL}`);
  }
  #onQuestionAnswer() {
    const questionLineCount = Math.ceil(
      (0, import_wcwidth.default)(stripAnsi(this.#getQuestionQuery() + this.answer)) / this.stdout.columns
    );
    this.stdout.moveCursor(-this.stdout.columns, -questionLineCount);
    this.stdout.clearScreenDown();
    for (const validator of this.#validators) {
      if (!validator.validate(this.answer)) {
        const error = validator.error(this.answer);
        this.#setQuestionSuffixError(error);
        this.answerBuffer = this.#question();
        return;
      }
    }
    this.answerBuffer = void 0;
    this.#writeAnswer();
  }
  question() {
    return new Promise(async (resolve, reject) => {
      this.answer = this.agent.nextAnswers.shift();
      if (this.answer !== void 0) {
        this.#writeAnswer();
        this.destroy();
        resolve(this.answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.answer = await this.#question();
      if (this.answer === "" && this.defaultValue) {
        this.answer = this.defaultValue;
      }
      this.#onQuestionAnswer();
      while (this.answerBuffer !== void 0) {
        this.answer = await this.answerBuffer;
        this.#onQuestionAnswer();
      }
      this.destroy();
      resolve(this.answer);
    });
  }
};

// src/prompts/confirm.ts
var import_node_os3 = require("os");
var import_kleur3 = __toESM(require("kleur"), 1);
var import_wcwidth2 = __toESM(require("@topcli/wcwidth"), 1);
var kToggleKeys = /* @__PURE__ */ new Set([
  "left",
  "right",
  "tab",
  "q",
  "a",
  "d",
  "h",
  "j",
  "k",
  "l",
  "space"
]);
var ConfirmPrompt = class extends AbstractPrompt {
  initial;
  selectedValue;
  fastAnswer;
  #boundKeyPressEvent;
  #boundExitEvent;
  constructor(options) {
    const {
      initial = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.initial = initial;
    this.selectedValue = initial;
  }
  #getHint() {
    const Yes = import_kleur3.default.bold().underline().cyan("Yes");
    const No = import_kleur3.default.bold().underline().cyan("No");
    return this.selectedValue ? `${Yes}/No` : `Yes/${No}`;
  }
  #render() {
    this.write(this.#getQuestionQuery());
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.write(questionQuery);
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #onKeypress(resolve, value, key) {
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor((0, import_wcwidth2.default)(stripAnsi(this.#getQuestionQuery())) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    if (key.name === "return") {
      resolve(this.selectedValue);
      return;
    }
    if (kToggleKeys.has(key.name ?? "")) {
      this.selectedValue = !this.selectedValue;
    }
    if (key.name === "y") {
      this.selectedValue = true;
      resolve(true);
      this.fastAnswer = true;
    } else if (key.name === "n") {
      this.selectedValue = false;
      resolve(false);
      this.fastAnswer = true;
    }
    if (!this.fastAnswer) {
      this.#render();
    }
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
  }
  #getQuestionQuery() {
    const query = import_kleur3.default.bold(`${SYMBOLS.QuestionMark} ${this.message}`);
    return `${query} ${this.#getHint()}`;
  }
  #onQuestionAnswer() {
    this.clearLastLine();
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor((0, import_wcwidth2.default)(stripAnsi(this.#getQuestionQuery())) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    this.write(`${this.selectedValue ? SYMBOLS.Tick : SYMBOLS.Cross} ${import_kleur3.default.bold(this.message)}${import_node_os3.EOL}`);
  }
  confirm() {
    return new Promise(async (resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.selectedValue = answer;
        this.#onQuestionAnswer();
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      try {
        await this.#question();
        this.#onQuestionAnswer();
        resolve(this.selectedValue);
      } finally {
        this.write(SYMBOLS.ShowCursor);
        this.#onProcessExit();
        process.off("exit", this.#boundExitEvent);
        this.destroy();
      }
    });
  }
};

// src/prompts/select.ts
var import_node_os4 = require("os");
var import_kleur4 = __toESM(require("kleur"), 1);
var import_wcwidth3 = __toESM(require("@topcli/wcwidth"), 1);
var kRequiredChoiceProperties = ["label", "value"];
var SelectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  activeIndex = 0;
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      validators = [],
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${import_node_os4.EOL}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceSelected = choiceIndex === this.activeIndex;
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = " ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous;
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next;
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? `${SYMBOLS.Pointer} ` : "  "}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const color = isChoiceSelected ? import_kleur4.default.white().bold : import_kleur4.default.gray;
      const str = `${prefix}${color(`${formattedLabel}${formattedDescription}`)}${import_node_os4.EOL}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(choice) {
    const symbolPrefix = choice === "" ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${symbolPrefix} ${import_kleur4.default.bold(this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = import_kleur4.default.yellow(typeof choice === "string" ? choice : choice.label);
    this.write(`${prefix} ${formattedChoice}${import_node_os4.EOL}`);
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.name === "return") {
      const choice = this.filteredChoices[this.activeIndex] || "";
      const label = typeof choice === "string" ? choice : choice.label;
      const value = typeof choice === "string" ? choice : choice.value;
      for (const validator of this.#validators) {
        if (!validator.validate(value)) {
          const error = validator.error(value);
          render({ error });
          return;
        }
      }
      render({ clearRender: true });
      if (!this.options.ignoreValues?.includes(value)) {
        this.#showAnsweredQuestion(label);
      }
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(value);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  select() {
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.#showAnsweredQuestion(answer);
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              (0, import_wcwidth3.default)(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            (0, import_wcwidth3.default)(stripAnsi(this.questionMessage)) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil((0, import_wcwidth3.default)(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = "";
    if (error) {
      hint = ` ${hint.length > 0 ? " " : ""}${import_kleur4.default.red().bold(`[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${import_kleur4.default.bold(this.message)}${hint}`;
    this.write(`${this.questionMessage}${import_node_os4.EOL}`);
  }
};

// src/prompts/multiselect.ts
var import_node_os5 = require("os");
var import_kleur5 = __toESM(require("kleur"), 1);
var import_wcwidth4 = __toESM(require("@topcli/wcwidth"), 1);
var kRequiredChoiceProperties2 = ["label", "value"];
var MultiselectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  #showHint;
  activeIndex = 0;
  selectedIndexes = /* @__PURE__ */ new Set();
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      preSelectedChoices,
      validators = [],
      showHint = true,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    this.#showHint = showHint;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties2) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
    if (!preSelectedChoices) {
      return;
    }
    for (const choice of preSelectedChoices) {
      const choiceIndex = this.filteredChoices.findIndex((item) => {
        if (typeof item === "string") {
          return item === choice;
        }
        return item.value === choice;
      });
      if (choiceIndex === -1) {
        this.destroy();
        throw new Error(`Invalid pre-selected choice: ${typeof choice === "string" ? choice : choice.value}`);
      }
      this.selectedIndexes.add(choiceIndex);
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${import_node_os5.EOL}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceActive = choiceIndex === this.activeIndex;
      const isChoiceSelected = this.selectedIndexes.has(choiceIndex);
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = "  ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous + " ";
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next + " ";
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? SYMBOLS.Active : SYMBOLS.Inactive}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const color = isChoiceActive ? import_kleur5.default.white().bold : import_kleur5.default.gray;
      const str = `${prefix} ${color(`${formattedLabel}${formattedDescription}`)}${import_node_os5.EOL}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(choices, isAgentAnswer = false) {
    const prefixSymbol = this.selectedIndexes.size === 0 && !isAgentAnswer ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${prefixSymbol} ${import_kleur5.default.bold(this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = import_kleur5.default.yellow(choices);
    this.write(`${prefix}${choices ? ` ${formattedChoice}` : ""}${import_node_os5.EOL}`);
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.ctrl && key.name === "a") {
      this.selectedIndexes = this.selectedIndexes.size === this.filteredChoices.length ? /* @__PURE__ */ new Set() : new Set(this.filteredChoices.map((_, index) => index));
      render();
    } else if (key.name === "right") {
      this.selectedIndexes.add(this.activeIndex);
      render();
    } else if (key.name === "left") {
      this.selectedIndexes = new Set([...this.selectedIndexes].filter((index) => index !== this.activeIndex));
      render();
    } else if (key.name === "return") {
      const labels = [...this.selectedIndexes].map((index) => {
        const choice = this.filteredChoices[index];
        return typeof choice === "string" ? choice : choice.label;
      });
      const values = [...this.selectedIndexes].map((index) => {
        const choice = this.filteredChoices[index];
        return typeof choice === "string" ? choice : choice.value;
      });
      for (const validator of this.#validators) {
        if (!validator.validate(values)) {
          const error = validator.error(values);
          render({ error });
          return;
        }
      }
      render({ clearRender: true });
      this.#showAnsweredQuestion(labels.join(", "));
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(values);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.selectedIndexes.clear();
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  multiselect() {
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        const formatedAnser = Array.isArray(answer) ? answer.join(", ") : answer;
        this.#showAnsweredQuestion(formatedAnser, true);
        this.destroy();
        resolve(Array.isArray(answer) ? answer : [answer]);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              (0, import_wcwidth4.default)(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            (0, import_wcwidth4.default)(stripAnsi(this.questionMessage)) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil((0, import_wcwidth4.default)(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = this.#showHint ? import_kleur5.default.gray(
      // eslint-disable-next-line max-len
      `(Press ${import_kleur5.default.bold("<Ctrl+A>")} to toggle all, ${import_kleur5.default.bold("<Left/Right>")} to toggle, ${import_kleur5.default.bold("<Return>")} to submit)`
    ) : "";
    if (error) {
      hint += `${hint.length > 0 ? " " : ""}${import_kleur5.default.red().bold(`[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${import_kleur5.default.bold(this.message)}${hint.length > 0 ? ` ${hint}` : ""}`;
    this.write(`${this.questionMessage}${import_node_os5.EOL}`);
  }
};

// src/validators.ts
function required() {
  return {
    validate: (input) => Array.isArray(input) ? input.length > 0 : Boolean(input),
    error: () => "required"
  };
}

// index.ts
async function question(message, options = {}) {
  return new QuestionPrompt({ ...options, message }).question();
}
async function select(message, options) {
  const selectPrompt = new SelectPrompt({ ...options, message });
  return selectPrompt.select();
}
async function confirm(message, options) {
  const confirmPrompt = new ConfirmPrompt({ ...options, message });
  return confirmPrompt.confirm();
}
async function multiselect(message, options) {
  const multiselectPrompt = new MultiselectPrompt({ ...options, message });
  return multiselectPrompt.multiselect();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PromptAgent,
  confirm,
  multiselect,
  question,
  required,
  select
});
